generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AuditLog {
  id           Int      @id @default(autoincrement())
  tenantId     Int
  actorUserId  Int?
  targetUserId Int?
  entityType   String? // e.g. "DOCUMENT", "FOLDER", "USER"
  entityId     String? // polymorphic ID
  action       String
  module       String? // e.g. "DMS", "AUTH", "SYSTEM" (Future Proofing)
  details      String?
  metadata     Json? // Structured data
  ipAddress    String?
  createdAt    DateTime @default(now())
  actor        User?    @relation("AuditActor", fields: [actorUserId], references: [id])
  target       User?    @relation("AuditTarget", fields: [targetUserId], references: [id])
  tenant       Tenant   @relation(fields: [tenantId], references: [id])

  // PARTITIONING STRATEGY (Comment Only):
  // For high-scale (>100M rows), verify PostgreSQL native partitioning.
  // Recommend partitioning by Range (createdAt) to facilitate efficient 
  // data retention (dropping old partitions) or List (tenantId) for strict isolation.
  // Current schema is efficient up to ~50M rows per table with proper indexing.

  @@index([action])
  @@index([actorUserId])
  @@index([targetUserId])
  @@index([tenantId])
  // OPTIMIZED INDICES
  // 1. Document History: Supports filtering by entity AND sorting by time.
  // We include 'createdAt' to avoid a sort step in the DB.
  // Replaces the previous [tenantId, entityType, entityId] index (prefix match).
  @@index([tenantId, entityType, entityId, createdAt])
  // 2. Module History: Supports "Show me all DMS activity" sorted by time.
  @@index([tenantId, module, createdAt])
}

model MfaBackupCode {
  id        Int      @id @default(autoincrement())
  userId    Int
  codeHash  String
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model PasswordResetRequest {
  id          Int      @id @default(autoincrement())
  email       String
  ipAddress   String
  requestedAt DateTime @default(now())

  @@index([email, requestedAt])
  @@index([ipAddress, requestedAt])
}

model PasswordResetToken {
  id        Int       @id @default(autoincrement())
  userId    Int
  tokenHash String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])

  @@index([tokenHash])
}

model Permission {
  id             Int              @id @default(autoincrement())
  code           String           @unique
  description    String?
  RolePermission RolePermission[]
}

model RefreshToken {
  id              Int       @id @default(autoincrement())
  userId          Int
  tokenHash       String
  mfaVerified     Boolean   @default(false)
  deviceInfo      String?
  ipAddress       String?
  lastActiveAt    DateTime?
  expiresAt       DateTime
  revokedAt       DateTime?
  revokedByIp     String?
  replacedByToken String?
  createdAt       DateTime  @default(now())
  user            User      @relation(fields: [userId], references: [id])

  @@index([tokenHash])
}

model Role {
  id                Int                @id @default(autoincrement())
  tenantId          Int
  name              String
  description       String?
  isSystem          Boolean            @default(false)
  requiresMfa       Boolean            @default(false)
  isActive          Boolean            @default(true)
  createdAt         DateTime           @default(now())
  tenant            Tenant             @relation(fields: [tenantId], references: [id])
  rolePermissions   RolePermission[]
  userRoles         UserRole[]
  folderPermissions FolderPermission[]

  @@unique([tenantId, name])
}

model RolePermission {
  roleId       Int
  permissionId Int
  permission   Permission @relation(fields: [permissionId], references: [id])
  role         Role       @relation(fields: [roleId], references: [id])

  @@id([roleId, permissionId])
}

model SecurityAlert {
  id        Int      @id @default(autoincrement())
  userId    Int
  type      String
  title     String
  message   String
  severity  String
  metadata  String?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])

  @@index([isRead])
  @@index([userId])
}

model Tenant {
  id                Int                @id @default(autoincrement())
  code              String             @unique
  name              String
  isActive          Boolean            @default(true)
  createdAt         DateTime           @default(now())
  auditLogs         AuditLog[]
  roles             Role[]
  users             User[]
  invites           UserInvite[]
  folders           Folder[]
  documents         Document[]
  versions          DocumentVersion[]
  shares            ShareLink[]
  workflows         WorkflowHistory[]
  documentTypes     DocumentType[]
  documentSequences DocumentSequence[]

  // V2 Relations
  documentReviews          DocumentReview[]
  reviewReminderLogs       ReviewReminderLog[]
  folderPermissions        FolderPermission[]
  documentComments         DocumentComment[]
  documentAcknowledgements DocumentAcknowledgement[]
}

model User {
  id                  Int                  @id @default(autoincrement())
  tenantId            Int
  fullName            String
  email               String
  passwordHash        String?
  status              String               @default("PENDING")
  mfaEnabled          Boolean              @default(false)
  mfaSecret           String?
  mfaSetupRequired    Boolean              @default(false)
  isActive            Boolean              @default(true)
  isLocked            Boolean              @default(false)
  lastLoginAt         DateTime?
  createdAt           DateTime             @default(now())
  createdBy           Int?
  updatedAt           DateTime?
  updatedBy           Int?
  auditLogsInitiated  AuditLog[]           @relation("AuditActor")
  auditLogsReceived   AuditLog[]           @relation("AuditTarget")
  mfaBackupCodes      MfaBackupCode[]
  passwordResetTokens PasswordResetToken[]
  refreshTokens       RefreshToken[]
  securityAlerts      SecurityAlert[]
  tenant              Tenant               @relation(fields: [tenantId], references: [id])
  invites             UserInvite[]
  userRoles           UserRole[]

  // DMS Relations
  documentsCreated Document[]        @relation("DocumentCreatedBy")
  documentsUpdated Document[]        @relation("DocumentUpdatedBy")
  versionsCreated  DocumentVersion[] @relation("VersionCreatedBy")

  // V2 Relations
  documentReviews          DocumentReview[]
  documentComments         DocumentComment[]
  documentAcknowledgements DocumentAcknowledgement[]

  @@unique([tenantId, email])
}

model UserInvite {
  id        String    @id @default(cuid())
  tenantId  Int
  email     String
  tokenHash String
  expiresAt DateTime
  createdBy Int
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  creator   User      @relation(fields: [createdBy], references: [id])
  tenant    Tenant    @relation(fields: [tenantId], references: [id])

  @@index([tenantId, email])
  @@index([tokenHash])
}

model UserRole {
  userId     Int
  roleId     Int
  assignedAt DateTime @default(now())
  assignedBy Int?
  role       Role     @relation(fields: [roleId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@id([userId, roleId])
}

model Folder {
  id       String  @id @default(cuid())
  name     String
  parentId String?
  tenantId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById Int
  updatedById Int?

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parent   Folder?  @relation("FolderToFolder", fields: [parentId], references: [id])
  children Folder[] @relation("FolderToFolder")

  documents   Document[]
  permissions FolderPermission[]

  @@unique([tenantId, parentId, name]) // Prevent duplicate folder names in same parent
  @@index([tenantId])
  @@index([tenantId, parentId])
}

model Document {
  id          String  @id @default(cuid())
  title       String
  description String?

  folderId String?
  tenantId Int

  status        DocumentStatus @default(DRAFT)
  expiryDate    DateTime?
  effectiveDate DateTime?

  currentVersionId String?

  createdById Int
  updatedById Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant    Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  folder    Folder? @relation(fields: [folderId], references: [id], onDelete: Restrict)
  createdBy User    @relation("DocumentCreatedBy", fields: [createdById], references: [id])
  updatedBy User?   @relation("DocumentUpdatedBy", fields: [updatedById], references: [id])

  type   DocumentType? @relation(fields: [typeId], references: [id])
  typeId String?

  // New metadata
  documentNumber String? // Optional for migration, will be made required

  versions       DocumentVersion[]
  currentVersion DocumentVersion?  @relation("CurrentVersion", fields: [currentVersionId], references: [id])

  workflowHistory WorkflowHistory[]
  shares          ShareLink[]

  // V2 Relations
  reviews          DocumentReview[]
  comments         DocumentComment[]
  acknowledgements DocumentAcknowledgement[]

  // Supersedence
  supersedesId String?
  supersedes   Document? @relation("Supersedes", fields: [supersedesId], references: [id])
  
  supersededById String? @unique
  supersededBy   Document? @relation("SupersededBy", fields: [supersededById], references: [id])
  
  // Reverse relations for the above (since they are self-relations)
  childrenSuperseding Document[] @relation("Supersedes") 
  parentSuperseded    Document?  @relation("SupersededBy")

  @@unique([tenantId, supersedesId])
  @@unique([tenantId, documentNumber])
  @@index([tenantId])
  @@index([tenantId, folderId])
  @@index([tenantId, status])
  @@index([tenantId, title])
  @@index([tenantId, typeId])
  @@index([tenantId, expiryDate])
}

model DocumentType {
  id          String   @id @default(cuid())
  name        String
  tenantId    Int
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedById Int?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  documents Document[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@index([tenantId, isActive])
}

model DocumentSequence {
  id        Int      @id @default(autoincrement())
  tenantId  Int
  year      Int
  current   Int      @default(0)
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, year])
}

enum DocumentStatus {
  DRAFT
  SUBMITTED
  REJECTED
  APPROVED
  OBSOLETE
}

model DocumentVersion {
  id         String @id @default(cuid())
  documentId String
  tenantId   Int

  versionNumber Int
  fileName      String
  fileSize      Int
  mimeType      String

  storageKey String // tenantId/documentId/version.ext
  
  // V3 Additions
  contentType String  @default("FILE") // FILE | INLINE
  contentJson Json?
  isFrozen    Boolean @default(false)

  createdById Int
  createdAt   DateTime @default(now())

  // Relations
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document  Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  createdBy User     @relation("VersionCreatedBy", fields: [createdById], references: [id])

  isCurrentFor     Document[]                @relation("CurrentVersion")
  acknowledgements DocumentAcknowledgement[]
  attachments      DocumentVersionAttachment[]

  @@unique([documentId, versionNumber])
  @@index([tenantId])
  @@index([tenantId, documentId])
}

model DocumentVersionAttachment {
  id          String   @id @default(uuid())
  versionId   String
  tenantId    Int
  fileName    String
  storageKey  String
  mimeType    String
  fileSize    Int
  createdById String
  createdAt   DateTime @default(now())

  version     DocumentVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)

  @@index([tenantId, versionId])
}

model ShareLink {
  id         String @id @default(cuid())
  documentId String
  tenantId   Int

  token      String    @unique
  expiresAt  DateTime?
  maxClicks  Int? // Max number of allowed accesses
  clickCount Int       @default(0) // Current access count

  createdById Int
  createdAt   DateTime @default(now())

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, documentId])
  @@index([tenantId, expiresAt])
}

model WorkflowHistory {
  id         String @id @default(cuid())
  documentId String
  tenantId   Int

  fromStatus DocumentStatus?
  toStatus   DocumentStatus
  comment    String?

  actorUserId Int
  createdAt   DateTime @default(now())

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, documentId])
}

// --- DMS V2 Extensions ---

model DocumentReview {
  id             String       @id @default(uuid())
  documentId     String
  reviewerUserId Int
  stageNumber    Int
  status         ReviewStatus @default(PENDING)
  reviewedAt     DateTime?
  comment        String?
  tenantId       Int
  createdAt      DateTime     @default(now())

  // Relations
  tenant            Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document          Document            @relation(fields: [documentId], references: [id], onDelete: Cascade)
  reviewer          User                @relation(fields: [reviewerUserId], references: [id])
  ReviewReminderLog ReviewReminderLog[]

  @@index([tenantId, documentId])
  @@index([tenantId, reviewerUserId])
}

model ReviewReminderLog {
  id               String   @id @default(uuid())
  documentReviewId String
  sentAt           DateTime @default(now())
  tenantId         Int

  // Relations
  tenant Tenant         @relation(fields: [tenantId], references: [id])
  review DocumentReview @relation(fields: [documentReviewId], references: [id], onDelete: Cascade)
}

model FolderPermission {
  id         String               @id @default(uuid())
  folderId   String
  roleId     Int
  permission FolderPermissionType
  tenantId   Int

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id])
  folder Folder @relation(fields: [folderId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id])

  @@index([tenantId, folderId])
}

model DocumentComment {
  id         String   @id @default(uuid())
  documentId String
  userId     Int
  content    String
  tenantId   Int
  createdAt  DateTime @default(now())

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id])
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@index([tenantId, documentId])
}

model DocumentAcknowledgement {
  id             String   @id @default(uuid())
  documentId     String
  versionId      String
  userId         Int
  acknowledgedAt DateTime @default(now())
  tenantId       Int

  // Relations
  tenant   Tenant          @relation(fields: [tenantId], references: [id])
  document Document        @relation(fields: [documentId], references: [id], onDelete: Cascade)
  version  DocumentVersion @relation(fields: [versionId], references: [id])
  user     User            @relation(fields: [userId], references: [id])

  @@unique([tenantId, documentId, userId])
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum FolderPermissionType {
  READ
  WRITE
  REVIEW
}
